#+TITLE: Emacs Configuration
#+AUTHOR: Zachary Smith
#+EMAIL: z@xmyth.me
#+OPTIONS: toc:nil num:nil

Lots of ideas stolen (with admiration) from [[https://github.com/hrs][Harry R. Schwartz]].

* Core Package Management Setup
** Diminish

I make use of [[https://github.com/emacsmirror/diminish][diminish]] so make sure it is installed.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'diminish)
  (package-refresh-contents)
  (package-install 'diminish))
#+END_SRC

** use-package

Use [[https://github.com/jwiegley/use-package][use-package]] for managing packages in emacs.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-verbose t)
(setq use-package-always-ensure t)

(eval-when-compile
 (require 'use-package))
#+END_SRC

* Basic Configurations

Use [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults]]. Rather than using /sensible-defaults/use-all-settings/, I
select the defaults that I want (which admittedly is most of them). Comment out
the ones I don't want to make it clear what I'm excluding. My own personal
customizations are added at the end of the block.

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/packages/sensible-defaults.el/sensible-defaults.el")

  (sensible-defaults/backup-to-temp-directory)
  (sensible-defaults/open-files-from-home-directory)
  (sensible-defaults/increase-gc-threshold)
  (sensible-defaults/delete-trailing-whitespace)
  (sensible-defaults/treat-camelcase-as-separate-words)
  (sensible-defaults/automatically-follow-symlinks)
  (sensible-defaults/make-scripts-executable)
  ;;(sensible-defaults/single-space-after-periods)
  (sensible-defaults/offer-to-create-parent-directories-on-save)
  (sensible-defaults/apply-changes-to-highlighted-region)
  (sensible-defaults/overwrite-selected-text)
  (sensible-defaults/ensure-that-files-end-with-newline)
  (sensible-defaults/confirm-closing-emacs)
  (sensible-defaults/quiet-startup)
  ;;(sensible-defaults/make-dired-file-sizes-human-readable)
  (sensible-defaults/shorten-yes-or-no)
  (sensible-defaults/always-highlight-code)
  (sensible-defaults/refresh-buffers-when-files-change)
  (sensible-defaults/show-matching-parens)
  (sensible-defaults/flash-screen-instead-of-ringing-bell)
  (sensible-defaults/set-default-line-length-to 80)
  (sensible-defaults/open-clicked-files-in-same-frame-on-mac)
  (sensible-defaults/yank-to-point-on-mouse-click)

  ;; use all the key-bindings
  (sensible-defaults/use-all-keybindings)

  ;; set require-newline to TRUE. I may consider setting to 'visit-save but that might be a bit
  ;; too noisy - Since I am noramally working in git repos, I typically only want to add newlines to files
  ;; I'm editing rather than have to deal with a bunch of visited files with changes that need to be saved
  (use-package emacs
    :config
    (setq mode-require-final-newline t))

  ;; I really don't have a use for emacs lock files and they clutter up the fs tree.
  (use-package emacs
    :config
    (setq create-lockfiles nil))
#+END_SRC

Show line numbers by default. If using Emacs 26 or above, use
/global-display-line-numbers-mode/. Otherwise, use [[https://elpa.gnu.org/packages/nlinum.html][nlinum]].

#+BEGIN_SRC emacs-lisp
  (if (< emacs-major-version 26)
      (use-package nlinum
        :diminish
        :config
        (global-nlinum-mode t)
        (setq nlinum-format "%d "))
    (global-display-line-numbers-mode))
#+end_src

Start the server by default
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (if (server-running-p)
      (message "Server already running - Not starting server for this session")
    (server-start))
#+END_SRC

I like to see the column numbers as well as line numbers

#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

Use spaces instead of tabs and set the default tabstop to 2

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
#+END_SRC

Don't litter my init file with custom settings

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)
#+END_SRC

If a file changes on disk, I want it to be reloaded/reverted in buffers

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

** Load Local Configurations

Sometimes a machine needs some customized configuration.

#+BEGIN_SRC emacs-lisp
  (setq local-cfg "~/.emacs.d/local.el")
  (if (file-exists-p local-cfg)
      (load-file local-cfg))
#+END_SRC

** Open configuration.org file

Opens the configuration.org file - handy so I don't have to open it by typing
the path out every time.

#+BEGIN_SRC emacs-lisp
    (defun zxmth/open-config-file (&optional new-window)
      "Open the emacs config"
      (interactive)
      (setq config-file "~/.emacs.d/configuration.org")
      (unless new-window (setq new-window nil))
      (if new-window
        (find-file-other-window config-file)
        (find-file config-file))
      (beginning-of-buffer))
    (global-set-key (kbd "C-x c") 'zxmth/open-config-file)
    (global-set-key (kbd "C-x C") (lambda ()
                                    (interactive)
                                    (zxmth/open-config-file t)))
#+END_SRC

** Reload configuration

Helper function and global key to reload init.el

#+BEGIN_SRC emacs-lisp
  (defun zxmth/reload-init-el ()
    "Reload the init.el"
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (global-set-key (kbd "C-x !") 'zxmth/reload-init-el)
#+END_SRC

* Packages

** Compile packages and prefer the newest version

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :diminish
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

** Use dash.el for some handy functions

#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
#+END_SRC

** exec-path-from-shell

Use shell PATH when launched from graphical environments

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell)

(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC

* Set personal information

** Contact Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Zachary Smith"
      user-mail-address "z@zxmth.us")
#+END_SRC

* Utility Functions

#+BEGIN_SRC emacs-lisp
  (defun zxmth/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun zxmth/disable-truncate-lines ()
    "Disable line truncation"
    (let ((inhibit-message t)
          message-log-max
          truncate-partial-width-windows)
      (toggle-truncate-lines t)))
#+END_SRC

* Directories

** dired

I borrowed pretty much all of this from [[https://gitlab.com/protesilaos/dotemacs/blob/master/emacs-init.org][Protesilaos Stavrou]] who has some
fantastic configurations. I was looking for information on dired and found [[https://www.youtube.com/watch?v=_2NAbPp_0zY][this
video]] he did which was great.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :custom
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (dired-isearch-filenames 'dwim)
  (delete-by-moving-to-trash t)
  (dired-listing-switches "-AFhlv --group-directories-first")
  (dired-dwim-target t)
  :hook
  (dired-mode . dired-hide-details-mode)
  (dired-mode . hl-line-mode)
  :bind (("s-d" . dired)
         ("s-D" . dired-other-window)))

(use-package find-dired
  :after dired
  :custom
  (find-ls-option ;; applies to `find-name-dired'
   '("-ls" . "-AFhlv --group-directories-first"))
  (find-name-arg "-iname"))

(use-package async
  :ensure t)

(use-package dired-async
  :ensure nil
  :after (dired async)
  :config
  (dired-async-mode 1))

(global-set-key (kbd "C-c d f") 'find-name-dired)
#+END_SRC

wdired is great for editing text to affect file names. You can rename things or
even create directories.

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :after dired
  :init
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+END_SRC

Honestly, I'm not sure why this isn't the default dired behavior but this tool
is a game changer.

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("<C-tab>" . dired-subtree-cycle)
              ("<S-iso-lefttab>" . dired-subtree-remove)))
#+END_SRC

Preview files in a directory.

#+BEGIN_SRC emacs-lisp
(use-package peep-dired
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("P" . peep-dired))
  :custom
  (peep-dired-cleanup-on-disable t)
  (peep-dired-ignored-extensions
   '("mkv" "webm" "mp4" "mp3" "ogg" "iso" "o" "ko" "elc" "exe" "class" "out" "rpm")))
#+END_SRC

Show git info for files in a dired buffer if they exist in a git repository.

#+BEGIN_SRC emacs-lisp
(use-package dired-git-info
  :ensure t
  :after dired
  :custom
  (dgi-commit-message-format "%h\t%s\t%cr")
  :bind (:map dired-mode-map
              (")" . dired-git-info-mode)))
#+END_SRC

Dired-narrow adds some helpful filtering to dired buffers

#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :ensure t
    :config
      (bind-key "C-c C-n" #'dired-narrow)
      (bind-key "C-c C-f" #'dired-narrow-fuzzy)
      (bind-key "C-c C-N" #'dired-narrow-regexp))
#+END_SRC

** neotree

This is an emacs version of the nerdtree in vim which I used to use.

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (global-set-key (kbd "C-\\") 'neotree-toggle)
    (global-set-key (kbd "C-x \\") 'neotree-find)
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)
          neo-window-width 55))
#+END_SRC

* Evil Mode

I'd resisted this for a while but see some benefit to using vim bindings

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (setq evil-default-state 'emacs) ;; use emacs state by default and toggle evil with C-z
    (evil-mode 1))
#+END_SRC

** evil-surround

   /vim-surround/ is amazing and I wanted something like it in emacs - this
   works great

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))
#+END_SRC

* Searching

** Auto-Complete

Enable auto-complete - I use the [[https://github.com/auto-complete/auto-complete][auto-complete]] package

/NOTE: This code is disabled as it seems that auto-complete may not longer be
supported. Going to try and and rely only on company mode below./

#+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :disabled
  :diminish
  :config
  (ac-config-default)
  (add-to-list 'ac-modes 'name-of-mod)
  (define-globalized-minor-mode zxmth/global-auto-complete-mode
    auto-complete-mode (lambda ()
                       (if (not (minibufferp (current-buffer)))
                         (auto-complete-mode 1))
                       ))
  (zxmth/global-auto-complete-mode t))
#+END_SRC

Use [[http://company-mode.github.io/][company-mode]] for some auto-complete functionality for packages that
depend on it.

#+BEGIN_SRC emacs-lisp
  (use-package company
     :config
     (add-hook 'after-init-hook 'global-company-mode))

  (global-set-key (kbd "C-|") 'company-complete-common)
#+END_SRC

** Ivy / Counsel / Swiper

Use [[https://github.com/abo-abo/swiper][Ivy, Counsel, and Swiper]] for completion front-end and search

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :diminish ivy-mode
    :bind
    ("C-c C-r" . 'ivy-resume)
    ("<f6>" . 'ivy-resume)
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    :bind ("M-]" . ivy-yank-word))

  (use-package counsel
    :ensure t
    :diminish counsel-mode
    :bind ("M-x" . counsel-M-x)

    :config
    (counsel-mode 1))

  (use-package swiper
    :ensure t
    :bind
    ("\C-s" . 'swiper))
#+END_SRC

** Silver Searcher

I have gotten pretty used to using Ag and find it handy with projectile.

#+BEGIN_SRC emacs-lisp
(use-package ag
   :config
   (setq ag-highlight-search t
         ag-reuse-window 't
         ag-reuse-buffers 't))
#+END_SRC

** Ripgrep

A fast grep that supports Occur-style editing in results buffers when wgrep is added.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t))

(use-package rg
  :ensure
  :after wgrep
  :config
  (setq rg-group-result t)
  (setq rg-hide-command t)
  (setq rg-show-columns nil)
  (setq rg-show-header t)
  (setq rg-custom-type-aliases nil)
  (setq rg-default-alias-fallback "all"))

  (global-set-key "\C-c(" 'rg)
  (global-set-key "\C-c)" 'rg-menu)
#+END_SRC

** Use Prescient for command history

#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :ensure t
    :custom
    (prescient-history-length 50)
    (prescient-save-file "~/.emacs.d/prescient-items")
    (prescient-filter-method '(fuzzy initialism regexp))
    :config
    (prescient-persist-mode 1))

  (use-package ivy-prescient
    :ensure t
    :after (prescient ivy)
    :custom
    (ivy-prescient-sort-commands
     '(:not swiper ivy-switch-buffer counsel-switch-buffer))
    (ivy-prescient-retain-classic-highlighting t)
    (ivy-prescient-enable-filtering t)
    (ivy-prescient-enable-sorting t)
    :config
    (defun zxmth/ivy-prescient-filters (str)
      "Specify an exception for `prescient-filter-method'.

  This new rule can be used to tailor the results of individual
  Ivy-powered commands, using `ivy-prescient-re-builder'."
      (let ((prescient-filter-method '(literal regexp)))
        (ivy-prescient-re-builder str)))

    (setq ivy-re-builders-alist
          '((counsel-rg . zxmth/ivy-prescient-filters)
            (counsel-grep . zxmth/ivy-prescient-filters)
            (counsel-yank-pop . zxmth/ivy-prescient-filters)
            (swiper . zxmth/ivy-prescient-filters)
            (swiper-isearch . zxmth/ivy-prescient-filters)
            (swiper-all . zxmth/ivy-prescient-filters)
            (t . ivy-prescient-re-builder)))
    (ivy-prescient-mode 1))
#+END_SRC

** Ivy Rich shows additional information

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :ensure t
  :config
  (setcdr (assq t ivy-format-functions-alist)
          #'ivy-format-function-line)
  (ivy-rich-mode 1))
#+END_SRC

** Ibuffer

Ibuffer is built into emacs and makes it easier to work with the buffer
list. Configuration stolen with admiration from [[https://protesilaos.com/dotemacs/][Prot]]. I also add in ibuffer-vc
mostly so I can group buffers by git project.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :config
    (setq ibuffer-expert t)
    (setq ibuffer-display-summary nil)
    (setq ibuffer-use-other-window nil)
    (setq ibuffer-show-empty-filter-groups nil)
    (setq ibuffer-movement-cycle nil)
    (setq ibuffer-default-sorting-mode 'filename/process)
    (setq ibuffer-use-header-line t)
    (setq ibuffer-default-shrink-to-minimum-size nil)
    (setq ibuffer-formats
          '((mark modified read-only locked " "
                  (name 30 30 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " " filename-and-process)
            (mark " "
                  (name 16 -1)
                  " " filename)))
    (setq ibuffer-saved-filter-groups nil)
    :hook (ibuffer-mode-hook . hl-line-mode)
    :bind (("C-x C-b" . ibuffer)
           :map ibuffer-mode-map
           ("* f" . ibuffer-mark-by-file-name-regexp)
           ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
           ("* n" . ibuffer-mark-by-name-regexp)
           ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
           ("/ g" . ibuffer-filter-by-content)))

  (use-package ibuffer-vc
    :ensure
    :after (ibuffer vc)
    :bind (:map ibuffer-mode-map
                ("/ V" . ibuffer-vc-set-filter-groups-by-vc-root)
                ("/ <deletechar>" . ibuffer-clear-filter-groups)))
#+END_SRC

* Switch and rebalance windows when splitting

** Window Movement

I like having keys to more easily jump around open buffers

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c k") 'windmove-up)
(global-set-key (kbd "C-c j") 'windmove-down)
(global-set-key (kbd "C-c h") 'windmove-left)
(global-set-key (kbd "C-c l") 'windmove-right)
#+END_SRC

** Window Resizing

I often resize buffers - bind keys to resizing that are similar to navigation
Use /C-u #/ to make larger resize increments.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<M-s-left>") 'shrink-window-horizontally)
(global-set-key (kbd "<M-s-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "<M-s-up>") 'enlarge-window)
(global-set-key (kbd "<M-s-down>") 'shrink-window)
#+END_SRC

I generally want to switch to the new window after creating it.

#+BEGIN_SRC emacs-lisp
(defun zxmth/split-window-below-and-switch ()
  "Split the window horizontally, then switch to the new pane."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun zxmth/split-window-right-and-switch ()
  "Split the window vertically, then switch to the new pane."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'zxmth/split-window-below-and-switch)
(global-set-key (kbd "C-x 3") 'zxmth/split-window-right-and-switch)

#+END_SRC

* Rearrange buffers and frames

** Transpose Frames

I'm using [[https://www.emacswiki.org/emacs/download/transpose-frame.el][Transpose Frame]] to rearrange buffers and frames. These are some keybindings
to make them easier to move around. I use tmux outside of emacs and wanted to make
emacs frames behave a bit more like tmux when rearranging.

#+BEGIN_SRC emacs-lisp
(use-package transpose-frame
  :config
  (global-set-key (kbd "C-x [") 'transpose-frame)
  (global-set-key (kbd "C-x <up>") 'flip-frame)
  (global-set-key (kbd "C-x <down>") 'flop-frame)
  (global-set-key (kbd "C-x ]") 'rotate-frame)
  (global-set-key (kbd "C-x <right>") 'rotate-frame-clockwise)
  (global-set-key (kbd "C-x <left>") 'rotate-frame-anticlockwise))
#+END_SRC

** Use winner-mode

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** switch-window

switch-window is great for jumping around frames

#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :config
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-minibuffer-shortcut ?z)
    (global-set-key (kbd "C-c o") 'switch-window)
    (global-set-key (kbd "C-c 1") 'switch-window-then-maximize)
    (global-set-key (kbd "C-c 2") 'switch-window-then-split-below)
    (global-set-key (kbd "C-c 3") 'switch-window-then-split-right)
    (global-set-key (kbd "C-c 0") 'switch-window-then-delete)

    (global-set-key (kbd "C-c 4 d") 'switch-window-then-dired)
    (global-set-key (kbd "C-c 4 f") 'switch-window-then-find-file)
    (global-set-key (kbd "C-c 4 r") 'switch-window-then-find-file-read-only)
    (global-set-key (kbd "C-c 4 C-f") 'switch-window-then-find-file)
    (global-set-key (kbd "C-c 4 C-o") 'switch-window-then-display-buffer)
    (global-set-key (kbd "C-c 4 0") 'switch-window-then-kill-buffer))
#+END_SRC

* Multiple Cursors

** Use [[https://github.com/magnars/multiple-cursors.el][Multiple Cursors]] by [[https://github.com/magnars][Magnar Sveen]]

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :config
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
#+END_SRC

* Registers & Bookmarks

** list-register

For some reason there doesn't appear to be a built-in way to list your registers
so we have to install a packaged to do it.

#+BEGIN_SRC emacs-lisp
  (use-package list-register
    :ensure t)
#+END_SRC

* Make Emacs look nicer

** Set dark & light themes

I use two themes - a dark and a light - and then toggle between them. When toggling,
I completely unload all themes before loading the new one to make sure
there is not overlap. Because of the theme loading is done on demand (and
repeatedly) I needed a way to customize the theme after it loads (each time) to
make various customizations so I created a simple mechanism to add a
post-theme-load hook.

#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
    :ensure t)

  (use-package spacemacs-common
    :ensure spacemacs-theme)

  (setq zxmth/themes '((dark . monokai)
                       (light . spacemacs-light)))

  ;; hooks to call after a theme is loaded.
  (setq zxmth/post-load-theme-hooks '((dark . zxmth/post-load-dark-theme)
                                      (light . zxmth/post-load-light-theme)))

  (defun zxmth/post-load-dark-theme (theme-name)
    "reset dired-subtree to dark theme colors (default)"
    (interactive)
    (custom-theme-set-faces
     theme-name
     '(dired-subtree-depth-1-face ((t (:background "#272822"))))
     '(dired-subtree-depth-2-face ((t (:background "#3E3D31"))))
     '(dired-subtree-depth-3-face ((t (:background "#272822"))))
     '(dired-subtree-depth-4-face ((t (:background "#3E3D31"))))
     '(dired-subtree-depth-5-face ((t (:background "#272822"))))
     '(dired-subtree-depth-6-face ((t (:background "#3E3D31"))))
     '(rg-match-face ((t (:foreground "#00bfff" :weight bold)))) ;; blue
     '(rg-filename-face ((t (:foreground "#ee7600" :weight bold)))) ;; orange
     '(wgrep-face ((t (:foreground "#ffd700" :weight bold)))) ;; yellow
     '(wgrep-done-face ((t (:foreground "#86C30D" :weight bold)))) ;; green
     '(wgrep-delete-face ((t (:forground "#F70057" :weight bold)))))) ;; red

  (defun zxmth/post-load-light-theme (theme-name)
    "make dired-subtree look nice in light theme"
    (interactive)
    (custom-theme-set-faces
     theme-name
     '(dired-subtree-depth-1-face ((t (:background "ivory2"))))
     '(dired-subtree-depth-2-face ((t (:background "ivory1"))))
     '(dired-subtree-depth-3-face ((t (:background "white"))))
     '(dired-subtree-depth-4-face ((t (:background "ivory2"))))
     '(dired-subtree-depth-5-face ((t (:background "ivory1"))))
     '(dired-subtree-depth-6-face ((t (:background "white"))))
     '(org-block ((t (:background "white"))))
     '(magit-diff-context-highlight ((t (:background "white"))))))

  (defun zxmth/load-theme (theme-key)
    (setq theme-name (alist-get theme-key zxmth/themes))
    (setq theme-hook (alist-get theme-key zxmth/post-load-theme-hooks))
    (load-theme theme-name t)
    (if theme-hook (funcall theme-hook theme-name)))

  (defun zxmth/disable-enabled-themes ()
    "Disable all themes currently enabled"
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))

  (defun zxmth/toggle-themes ()
    "Toggle between two themes and make some customizations"
    (interactive)
    ;; list of theme names
    (setq themes-to-toggle (mapcar 'cdr zxmth/themes))
    (setq theme-to-enable (car (remove (car custom-enabled-themes) themes-to-toggle)))
    (zxmth/disable-enabled-themes)
    ;; get key name from value
    (zxmth/load-theme (car (rassq theme-to-enable zxmth/themes))))

  (global-set-key (kbd "C-x /") 'zxmth/toggle-themes)

  ;; Load the dark theme by default
  (zxmth/load-theme 'dark)
#+END_SRC

** Icons

Install icons for use in dired, ivy, and others.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer 0.5)

(use-package all-the-icons-dired
  :ensure t
  :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

(use-package all-the-icons-ivy
  :ensure t
  :after (all-the-icons ivy)
  :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window ivy-switch-buffer))
  :config
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-dired-jump)
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-find-library)
    (all-the-icons-ivy-setup))
#+END_SRC

** Title bar

Simple function to toggle the visibility of the title bar. If I'm using
full-screen or a tiling manager, I may want to turn it off.

#+BEGIN_SRC emacs-lisp
  (defun zxmth/toggle-titlebar ()
    "Toggle the visibility of the titlebar"
    (interactive)
    (set-frame-parameter nil 'undecorated
                         (not (frame-parameter nil 'undecorated))))

  (global-set-key (kbd "C-x T") 'zxmth/toggle-titlebar)
#+END_SRC

* UI preferences

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when (or (window-system) (daemonp))
    (scroll-bar-mode -1))
#+END_SRC

Make the frame title match the current project as defined by Projectile

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use doom-modeline

I appreciate that this is a pretty simple and fast modeline implementation that
integrates with all-the-icons to make it look a little nicer.

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :after all-the-icons
    :config
    (setq doom-modeline-icon (display-graphic-p)
          doom-modeline-height 35
          doom-modeline-buffer-file-name-style 'truncate-with-project
          doom-modeline-project-detection 'projectile
          doom-modeline-major-mode-icon t
          doom-modeline-major-mode-color-icon t
          doom-modeline-buffer-state-icon t
          doom-modeline-buffer-modification-icon t
          doom-modeline-enable-word-count '(text-mode org-mode)
          doom-modeline-continuous-word-count-modes '(text-mode org-mode)
          doom-modeline-buffer-encoding t
          doom-modeline-lsp t
          doom-modeline-modal-icon t
          doom-modeline-indent-info t)
    :hook (after-init . doom-modeline-mode))
#+END_SRC

** Diminish minor modes

#+BEGIN_SRC emacs-lisp
(diminish 'auto-revert-mode)
#+END_SRC

* Org Mode Settings

** Some basic [[https://orgmode.org][Org-mode]] configurations

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
  (setq org-log-done 'time)
  (setq org-todo-keywords
    '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "BLOCKED(b!)" "|" "DONE(d!)" "CANCELED(c@)")
      (sequence "QUESTION(q)" "LEARNING(l)" "|" "ANSWERED(a@)" "FORGET(f)")))

  (setq org-todo-keyword-faces
    '(("STARTED" . "#b58900")
      ("WAITING" . "#d33682")
      ("BLOCKED" . (:foreground "white" :background "#d33682" :weight bold))
      ("CANCELED" . "#839496")
      ("QUESTION" . "#cb4b16")
      ("LEARNING" . "#6c71c4")
      ("ANSWERED" . "#859900")
      ("FORGET" . "#839496")))
#+END_SRC

** Use pretty bullets

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :init
  (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

** Syntax highlighting

Use syntax highlighting in source blocks while editing

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

** TAB behavior

Make TAB act as if it were issued in the language's major mode

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

** Templates

elisp template for org-mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

todo templates

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("q" "** QUESTION ?"))
  (add-to-list 'org-structure-template-alist
               '("t" "* TODO ?"))
  (add-to-list 'org-structure-template-alist
               '("tt" "** TODO ?"))
  (add-to-list 'org-structure-template-alist
               '("ttt" "*** TODO ?"))
#+END_SRC

I tend to organize my /brain/ file with date headers. Can't add a function call to
/org-structure-template-alist/ so created this simple function and bound it to a key.

#+BEGIN_SRC emacs-lisp
  (defun zxmth/add-org-date-header (&optional date-format)
    "Template to insert the date"
    (interactive)
    (unless date-format (setq date-format "%A, %B %d, %Y"))
    (insert (concat "* " (format-time-string date-format) "\n\n")))
  (define-key org-mode-map (kbd "C-:") 'zxmth/add-org-date-header)
#+END_SRC

** Configure org agenda, notes, and archive files

#+BEGIN_SRC emacs-lisp
  (defcustom org-agenda-dir-path org-directory
    "Path to my centrailized org files that comprise my agenda")

  (defcustom org-notes-directory (concat (file-name-as-directory org-directory) "notes")
    "Root of where org note files are saved")

  (defcustom org-remote-notes-directory nil
    "TRAMP path to a remote directory to search for notes")

  (defun org-agenda-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-agenda-dir-path) filename))

  (defcustom org-index-file (org-agenda-file-path "index.org")
    "Primary Org index file")

  (defcustom org-inbox-file (org-agenda-file-path "inbox.org")
    "Org file where new notes are captured - TODOs in this file can be moved to the org-index-file")

  (defcustom org-habit-file (org-agenda-file-path "habits.org")
    "Org file where repeating or habit based tasks are stored")

  (defcustom org-brain-file (org-agenda-file-path "brain.org")
    "File to collect lots of notes")

  (defcustom org-archive-location (concat (org-agenda-file-path "archive.org") "::* From %s")
    "File where completed Org tasks will be archived")

  (defcustom zxmth-org-agenda-files (-non-nil (list org-index-file org-inbox-file org-habit-file org-brain-file org-notes-directory org-remote-notes-directory))
    "List of files to include in constructing org agenda")

  (setq org-agenda-files zxmth-org-agenda-files)
#+END_SRC

** Auto-Save

Automatically save org files - mostly needed for keeping in sync over dropbox
since I tend to open and edit my agenda on multiple computers and don't always
remember to save... Also, don't log the message to the minibuffer because that
is annoying...

#+BEGIN_SRC emacs-lisp
  (add-hook 'auto-save-hook (lambda ()
                              (let ((inhibit-message t))
                                (org-save-all-org-buffers))))
#+END_SRC

** Capturing and storing tasks

Capture tasks in /inbox.org/ but copy them into the /index.org/ file and clean
up the /inbox/

#+BEGIN_SRC emacs-lisp
  (defun zxmth/move-tasks-from-inbox ()
    "Move contents of the org-inbox-file file to end of org-index-file and clear contents of org-inbox-file"
    (interactive)
    (when (file-exists-p org-inbox-file)
        (save-excursion
          (find-file org-index-file)
          (goto-char (point-max))
          (insert-file-contents org-inbox-file)
          ;; clear contents of the inbox after moving contents
          (find-file org-inbox-file)
          (delete-region (point-min) (point-max))
          (save-buffer)
          (kill-buffer))))
  (define-key org-mode-map (kbd "C-c C-x TAB") 'zxmth/move-tasks-from-inbox)
#+END_SRC

** Quick file access

Quickly open my index file

#+BEGIN_SRC emacs-lisp
  (defun zxmth/open-index-file ()
    "Open the file defined by variable org-index-file"
    (interactive)
    ;; first move any tasks over from the inbox
    (zxmth/move-tasks-from-inbox)
    (find-file org-index-file)
    (end-of-buffer))
  (global-set-key (kbd "C-c i") 'zxmth/open-index-file)

  (defun zxmth/open-brain-file ()
    "Open the main note taking document"
    (interactive)
    (find-file org-brain-file)
    (end-of-buffer))
  (global-set-key (kbd "C-c b") 'zxmth/open-brain-file)

  (defun zxmth/open-org-notes-dir ()
    "Open the main note taking document"
    (interactive)
    (find-file org-notes-directory)
    (end-of-buffer))
  (global-set-key (kbd "C-c o") 'zxmth/open-org-notes-dir)
#+END_SRC

** Capture template(s)

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-capture-templates
        '(("t" "TODO"
           entry
           (file+headline org-index-file "Tasks")
           "** TODO %?\n")
          ("q" "QUESTION"
           entry
           (file+headline org-index-file "Questions")
           "** QUESTION %?\n")))
#+END_SRC

Quick capture TODO

#+BEGIN_SRC emacs-lisp
  (defun zxmth/org-capture-todo ()
    "Prompt to quickly capture a TODO using the TODO template"
    (interactive)
    (org-capture :keys "t"))
  (global-set-key (kbd "C-c M-n") 'zxmth/org-capture-todo)

  (defun zxmth/org-capture-question ()
    "Prompt to quickly capture a QUESTION using the QUESTION template"
    (interactive)
    (org-capture :keys "q"))
  (global-set-key (kbd "C-c M-q") 'zxmth/org-capture-question)
#+END_SRC

** Archive DONE and CANCELED tasks

#+BEGIN_SRC emacs-lisp
  (defun zxmth/org-archive-complete-tasks (&optional archive-states)
    "Move DONE and CANCELED items to the org-archive-location"
    (interactive)
    (unless archive-states (setq archive-states '("DONE" "CANCELED")))
    (dolist (state archive-states)
      (org-map-entries 'org-archive-subtree (concat "/" state))))

  (define-key org-mode-map (kbd "\C-c A") 'zxmth/org-archive-complete-tasks)
#+END_SRC

** Enable spell-checking

I'm rael bad at spelling.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

** Agenda View

Build a custom agenda view that shows me TODOs marked as priority #A on top
followed by my tasks scheduled for the current day, tasks marked as started,
tasks marked as waiting, and then a list of all of my remaining TODOs

#+BEGIN_SRC emacs-lisp
  (defun zxmth/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.
           PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (defun zxmth/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun zxmth/org-skip-subtree-if-state-in (states)
    "Skip an agenda subtree if it has a todo state found in STATES"
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (skip nil))
      (dolist (state states skip)
        (setq task-state (org-entry-get nil "TODO"))
        (if (string= task-state state)
            (setq skip subtree-end)))))

  (defun zxmth/org-agenda-get-day-face (date)
    "Return the face DATE should be displayed with."
    '(:foreground "#eee8d5" :weight bold))

  (setq org-agenda-day-face-function 'zxmth/org-agenda-get-day-face)

  (setq org-agenda-custom-commands
        '(("d" "Daily Agenda"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-Priority Tasks:")))
            (tags "TODO=\"BLOCKED\""
                  ((org-agenda-overriding-header "Blocked:")))
            (agenda "" ((org-agenda-span 1)))
            (tags "TODO=\"WAITING\""
                  ((org-agenda-overriding-header "Waiting:")))
            (tags "TODO=\"STARTED\""
                  ((org-agenda-overriding-header "Started:")))
            (tags "TODO=\"QUESTION\"|TODO=\"LEARNING\""
                  ((org-agenda-overriding-header "Questions:")))
            (alltodo ""
                     ((org-agenda-skip-function '(or (zxmth/org-skip-subtree-if-habit)
                                                     (zxmth/org-skip-subtree-if-priority ?A)
                                                     (zxmth/org-skip-subtree-if-state-in '("WAITING" "STARTED" "BLOCKED" "QUESTION" "LEARNING"))
                                                     (org-agenda-skip-if nil '(scheduled deadline))
                                                     (org-agenda-skip-subtree-if 'regexp ":ignore:")))
                      (org-agenda-overriding-header "Backlog:")))))))

  (defun zxmth/pop-to-custom-daily-org-agenda ()
    "Visit the 'Daily Agenda' org agenda in the current window
         and close other windows"
    (interactive)
    (let ((org-agenda-window-setup 'only-window))
      (org-agenda nil "d")))

  (global-set-key (kbd "C-c M-A") 'zxmth/pop-to-custom-daily-org-agenda)

  (defun zxmth/show-daily-org-agenda ()
    "Show the 'Daily Agenda' in the current window"
    (interactive)
    (let ((org-agenda-window-setup 'other-window))
      (org-agenda nil "d")))

  (global-set-key (kbd "C-c M-a") 'zxmth/show-daily-org-agenda)
#+END_SRC

* Git

** Magit

Magit is amazing...and I barely know how to use it... This [[https://github.com/magit/magit/wiki/Cheatsheet][Cheat Sheet]] is helpful.

Turn on spell checking for commits - I make tons of typos :-(

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-x g" . magit-status)

  :config
  (setq git-commit-summary-max-length 50)
  (add-hook 'git-commit-mode-hook 'turn-on-flyspell))
#+END_SRC

* Programming

** prettier

   Use [[https://github.com/prettier/prettier][prettier]] to format code

#+BEGIN_SRC emacs-lisp
  (use-package prettier-js
      :ensure t)
  ;;  :config
  ;;  (add-hook 'rjsx-mode-hook 'prettier-js-mode)
  ;;  (add-hook 'js2-mode-hook 'prettier-js-mode)
  ;;  (add-hook 'typescript-mode 'prettier-js-mode)
#+END_SRC

** eslintd_fix

[[https://github.com/aaronjensen/eslintd-fix][Aaron Jensen's]] awesome eslintd fix package

#+BEGIN_SRC emacs-lisp
  (use-package eslintd-fix
    :config
    (add-hook 'rjsx-mode-hook 'eslintd-fix-mode)
    (add-hook 'js2-mode-hook 'eslintd-fix-mode)
    (add-hook 'typescript-mode 'eslintd-fix-mode))
#+END_SRC

** web-mode

Use web-mode for a host of basic web-y file formats

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :defer t
    :config
    (setq web-mode-attr-indent-offset 4)
    (setq web-mode-code-indent-offset 4)
    (setq web-mode-css-indent-offset 4)
    (setq web-mode-indent-style 4)
    (setq web-mode-markup-indent-offset 4)
    (setq web-mode-sql-indent-offset 4)
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
    (add-hook 'web-mode-hook
              (lambda ()
                (when (string-equal "tsx" (file-name-extension buffer-file-name))
                  (setup-tide-mode))))
    ;; enable typescript-tslint checker
    (flycheck-add-mode 'typescript-tslint 'web-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
 (add-hook 'web-mode-hook
           (lambda ()
             (rainbow-mode)
             (rspec-mode)))

 (zxmth/add-auto-mode
  'web-mode
  "\\.erb$"
  "\\.html$"
  "\\.rhtml$")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq web-mode-enable-auto-indentation nil)
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :config
    (progn
      (add-to-list
       'auto-mode-alist
       (cons "\.js$" (defun choose-js-type-mode ()
                       (save-excursion
                         (goto-char (point-min))
                         (let ((buff (current-buffer)))
                           (if (search-forward "React" nil t 1)
                               (rjsx-mode)
                             (js2-mode))))))))
    (setq js2-basic-offset 4)
    (setq js2-strict-missing-semi-warning nil)
    (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
    (add-hook 'js2-mode-hook #'zxmth/disable-truncate-lines)
    (add-hook 'js2-mode-hook #'setup-tide-mode))
#+END_SRC

** JSX

Use rjsx-mode for jsx files.

#+BEGIN_SRC emacs-lisp
    (use-package rjsx-mode
       :config
       (setq js2-basic-offset 4)
       (add-hook 'rjsx-mode-hook #'zxmth/disable-truncate-lines))
#+END_SRC

** JSON

Use json-mode

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :config
    (add-hook 'json-mode-hook #'zxmth/disable-truncate-lines))
#+END_SRC

** YAML

Use yaml-mode

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
      :config
      (add-hook 'yaml-mode-hook #'zxmth/turn-off-auto-fill))
#+END_SRC

** Tide (TypeScript)

#+BEGIN_SRC emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1)
    (setq tide-format-options '(:tabSize 2 :indentSize 2))
    (define-key tide-mode-map (kbd "\C-c r") 'tide-references)
    (define-key tide-mode-map (kbd "\C-c R") 'tide-rename-symbol)
    (define-key tide-mode-map (kbd "\C-c f") 'tide-fix))

  (use-package tide
    :config
    (setq typescript-indent-level 2)
    (setq company-tooltip-align-annotations t)
    :after (typescript-mode company flycheck)
    :hook ((typescript-mode . setup-tide-mode)
           (typescript-mode . tide-hl-identifier-mode)
           (before-save . tide-format-before-save)
           (typescript-mode . zxmth/disable-truncate-lines)))
#+END_SRC

** PHP

#+BEGIN_SRC emacs-lisp
  (use-package php-mode
    :mode "\\.php\\'"
    :ensure t
    :defer 1
    :config
    (add-hook 'php-mode-hook #'zxmth/disable-truncate-lines))
#+END_SRC

** Projectile

Use Projectile to help manage files related to projects.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer 1
    :init
    (setq projectile-keymap-prefix (kbd "C-c p"))
    :config
    (projectile-mode)
    (setq projectile-completion-system 'ivy)
    (setq projectile-enable-caching t)
    (setq projectile-mode-line
          '(:eval
            (format " [%s]"
                    (projectile-project-name)))))
#+END_SRC

Use projectile-ag to search project for symbol under the cursor

#+BEGIN_SRC emacs-lisp
(defun zxmth/search-project-for-symbol-at-point ()
  "Use `projectile-ag' to search the current project for `symbol-at-point'."
  (interactive)
  (projectile-ag (projectile-symbol-at-point)))
t
(global-set-key (kbd "C-c v") 'projectile-ag)
(global-set-key (kbd "C-c C-v") 'zxmth/search-project-for-symbol-at-point)
#+END_SRC

** Expand Region

[[https://github.com/magnars/][Magnar Sveen]] implemented one of my favorite features from IDEA...

#+BEGIN_SRC emacs-lisp
(use-package expand-region
   :config
   (global-set-key (kbd "C-%") 'er/expand-region))
#+END_SRC

** Rest Client

Handy, dandy rest client

#+BEGIN_SRC emacs-lisp
(use-package restclient)
#+END_SRC

** C mode

Use Linux coding standards for C - copied from [[https://www.kernel.org/doc/html/v4.10/process/coding-style.html#you-ve-made-a-mess-of-it][here]].

#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only ()
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))

  (add-hook 'c-mode-hook
          (lambda ()
                  (setq indent-tabs-mode t)
                  (setq show-trailing-whitespace t)
                  (c-set-style "linux-tabs-only")))

  (add-hook 'c-mode-hook #'zxmth/disable-truncate-lines)
#+END_SRC

** Scala

Relies on [[https://scalameta.org/metals/docs/editors/emacs.html][metal]] which needs to be install separately.

#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :mode "\\.s\\(cala\\|bt\\)$")

(use-package sbt-mode
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map)
   ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
   (setq sbt:program-options '("-Dsbt.supershell=false"))
)

(use-package lsp-mode
  ;; Optional - enable lsp-mode automatically in scala files
  :hook (scala-mode . lsp)
  :config (setq lsp-prefer-flymake nil))

;; Add company-lsp backend for metals
(use-package company-lsp)
#+END_SRC

* Writing

** Flyspell

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :diminish 'flyspell-mode)
#+END_SRC

** Markdown

I like to write in markdown somtimes.
I often write markdown that will appear on Github...so prefer gfm by default.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands gfm-mode
  :mode (("\\.md$" . gfm-mode))
  :config
  (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
  (add-hook 'gfm-mode-hook 'flyspell-mode))
#+END_SRC

** Wrap paragraphs

/AutoFillMode/ automatically wraps paragraphs. This is typically what I want so
this should make sure that it wraps by default. Sometimes I don't want to use it
so give me a way to turn it off, too.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'gfm-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

Helper function to disable auto-fill mode; the opposite of the built-in
turn-on-auto-fill

#+BEGIN_SRC emacs-lisp
  (defun zxmth/turn-off-auto-fill ()
    "Disable auto-fill"
    (interactive)
    (auto-fill-mode -1))
#+END_SRC

* Helpers

** Google This

Searching from within emacs comes in handy

#+BEGIN_SRC emacs-lisp
  (use-package google-this
    :ensure t
    :config
    (global-set-key (kbd "C-c /") 'google-this-mode-submap))
#+END_SRC

** Time

Show the time in 24 hour format

#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode)
#+END_SRC

/That's it for now!/
